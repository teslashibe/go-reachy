// Package spark provides AI-powered idea collection for Eva.
// "A spark of inspiration" - capture ideas, accumulate context, and develop plans.
package spark

import (
	"fmt"
	"time"
)

// Spark represents a captured idea/inspiration with accumulated context and optional plan.
type Spark struct {
	// ID is a unique identifier (UUID)
	ID string `json:"id"`

	// Title is an AI-generated concise title for the spark
	Title string `json:"title"`

	// RawContent is the original idea as captured from the user
	RawContent string `json:"raw_content"`

	// Context is a list of additional context/inspiration added over time
	Context []Context `json:"context,omitempty"`

	// Plan is an optional AI-generated action plan
	Plan *Plan `json:"plan,omitempty"`

	// Tags are AI-generated tags for categorization
	Tags []string `json:"tags,omitempty"`

	// GoogleDocID is the ID of the synced Google Doc (empty if not synced)
	GoogleDocID string `json:"google_doc_id,omitempty"`

	// SyncStatus indicates the sync state with Google Docs
	SyncStatus SyncStatus `json:"sync_status"`

	// CreatedAt is when the spark was first captured
	CreatedAt time.Time `json:"created_at"`

	// UpdatedAt is when the spark was last modified
	UpdatedAt time.Time `json:"updated_at"`
}

// Context represents additional context/inspiration added to a spark.
type Context struct {
	// Content is the context text
	Content string `json:"content"`

	// AddedAt is when this context was added
	AddedAt time.Time `json:"added_at"`

	// Source indicates where this context came from
	Source ContextSource `json:"source"`
}

// ContextSource indicates the origin of a context entry.
type ContextSource string

const (
	// SourceVoice indicates context added via voice
	SourceVoice ContextSource = "voice"

	// SourceWeb indicates context added via web UI
	SourceWeb ContextSource = "web"

	// SourceSearch indicates context from web search
	SourceSearch ContextSource = "search"

	// SourceAI indicates context generated by AI
	SourceAI ContextSource = "ai"
)

// Plan represents an AI-generated action plan for a spark.
type Plan struct {
	// Summary is a 2-3 sentence overview of the plan
	Summary string `json:"summary"`

	// Steps are concrete actionable items
	Steps []string `json:"steps"`

	// Resources are suggested resources based on context
	Resources []string `json:"resources,omitempty"`

	// LastUpdated is when the plan was last generated/updated
	LastUpdated time.Time `json:"last_updated"`
}

// SyncStatus indicates the sync state with Google Docs.
type SyncStatus string

const (
	// SyncNone indicates the spark has never been synced
	SyncNone SyncStatus = "none"

	// SyncPending indicates changes are waiting to be synced
	SyncPending SyncStatus = "pending"

	// SyncSynced indicates the spark is in sync with Google Docs
	SyncSynced SyncStatus = "synced"

	// SyncError indicates the last sync attempt failed
	SyncError SyncStatus = "error"
)

// NewSpark creates a new Spark with the given content.
// Title and tags should be generated separately via Gemini.
func NewSpark(id, rawContent string) *Spark {
	now := time.Now()
	return &Spark{
		ID:         id,
		RawContent: rawContent,
		Context:    make([]Context, 0),
		Tags:       make([]string, 0),
		SyncStatus: SyncNone,
		CreatedAt:  now,
		UpdatedAt:  now,
	}
}

// AddContext adds a new context entry to the spark.
func (s *Spark) AddContext(content string, source ContextSource) {
	s.Context = append(s.Context, Context{
		Content: content,
		AddedAt: time.Now(),
		Source:  source,
	})
	s.UpdatedAt = time.Now()
	s.MarkPendingSync()
}

// SetTitle updates the spark's title.
func (s *Spark) SetTitle(title string) {
	s.Title = title
	s.UpdatedAt = time.Now()
	s.MarkPendingSync()
}

// SetTags updates the spark's tags.
func (s *Spark) SetTags(tags []string) {
	s.Tags = tags
	s.UpdatedAt = time.Now()
}

// SetPlan updates the spark's plan.
func (s *Spark) SetPlan(plan *Plan) {
	s.Plan = plan
	s.UpdatedAt = time.Now()
	s.MarkPendingSync()
}

// MarkPendingSync marks the spark as needing sync (if it was previously synced).
func (s *Spark) MarkPendingSync() {
	if s.SyncStatus == SyncSynced {
		s.SyncStatus = SyncPending
	}
}

// MarkSynced marks the spark as synced with the given doc ID.
func (s *Spark) MarkSynced(docID string) {
	s.GoogleDocID = docID
	s.SyncStatus = SyncSynced
}

// MarkSyncError marks the spark as having a sync error.
func (s *Spark) MarkSyncError() {
	s.SyncStatus = SyncError
}

// ContextCount returns the number of context entries.
func (s *Spark) ContextCount() int {
	return len(s.Context)
}

// HasPlan returns true if the spark has a generated plan.
func (s *Spark) HasPlan() bool {
	return s.Plan != nil
}

// IsSynced returns true if the spark is synced with Google Docs.
func (s *Spark) IsSynced() bool {
	return s.SyncStatus == SyncSynced && s.GoogleDocID != ""
}

// NeedsSync returns true if the spark has pending changes to sync.
func (s *Spark) NeedsSync() bool {
	return s.SyncStatus == SyncPending
}

// Summary returns a brief summary of the spark for listing.
func (s *Spark) Summary() string {
	summary := s.Title
	if s.ContextCount() > 0 {
		summary += " (" + pluralize(s.ContextCount(), "context", "contexts") + ")"
	}
	if s.HasPlan() {
		summary += " [planned]"
	}
	return summary
}

// pluralize returns the singular or plural form based on count.
func pluralize(count int, singular, plural string) string {
	if count == 1 {
		return "1 " + singular
	}
	return fmt.Sprintf("%d %s", count, plural)
}

